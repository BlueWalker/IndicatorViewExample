package example.walker.blue.indicator;

import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;
import android.util.Log;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import walker.blue.core.lib.indicator.IndicatorView;

/**
 * Main activity of the application. 
 */
public class MainActivity extends ActionBarActivity {

    /**
     * Padding being applied to the indicator
     */
    private static final int PADDING = 200;

    /**
     * The acitvities instance of the indicatorView
     */
    private IndicatorView indicatorView;
    /**
     * Executor service used to execute our runnable
     */
    private ScheduledExecutorService executorService;
    private ScheduledFuture<?> future;

    /**
     * Runnable in charge of upating the indicator
     */
    private final Runnable runnable = new Runnable() {

        /**
         * Increment amount
         */
        private static final int INCREMENT = 10;

        /**
         * Current direction of movement
         */
        private boolean direction = true;

        @Override
        public void run() {
            float currentPos = indicatorView.getCurrentPosition();

            if (currentPos > indicatorView.getAdjustedMaxWidth()) {
                direction = false;
            } else if (currentPos < indicatorView.getPadding()) {
                direction = true;
            }

            if (direction) {
                currentPos += INCREMENT;
            } else {
                currentPos -= INCREMENT;
            }
            indicatorView.drawIndicatorAtPosition(currentPos);
        }
    };

    @Override
    protected void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        this.indicatorView = new IndicatorView(this);
        this.indicatorView.setLinePadding(PADDING);
        this.setContentView(indicatorView);
    }

    @Override
    protected void onPause() {
        super.onPause();
        this.future.cancel(true);
        Log.d(this.getClass().getName(), "Stopped scheduler");
    }

    @Override
    protected void onResume() {
        super.onResume();
        this.future = this.startScheduler();
    }

    /**
     * Start the scheduler that executes the runnable and updates the indicator
     *
     * @return the future generated by starting the scheduler
     */
    private ScheduledFuture<?> startScheduler() {
        Log.d(this.getClass().getName(), "Starting scheduler");
        this.executorService = Executors.newSingleThreadScheduledExecutor();
        return this.executorService.scheduleAtFixedRate(runnable, 0, 10, TimeUnit.MILLISECONDS);
    }
}